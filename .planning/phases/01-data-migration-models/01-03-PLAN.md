---
phase: 01-data-migration-models
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - app/Models/User.php
  - app/Models/Post.php
  - app/Models/Page.php
  - app/Models/Comment.php
  - app/Models/Category.php
  - app/Models/Tag.php
autonomous: true

must_haves:
  truths:
    - "All Laravel models have correct relationships defined"
    - "Post and Page models can retrieve their tags and categories"
    - "Comment model supports threaded replies"
    - "User model has author_name and wordpress_id accessors"
  artifacts:
    - path: "app/Models/Post.php"
      provides: "Post model with relationships"
      contains: "morphToMany"
    - path: "app/Models/Comment.php"
      provides: "Comment model with threading"
      contains: "belongsTo(Comment::class"
    - path: "app/Models/User.php"
      provides: "Extended user model"
      contains: "author_name"
  key_links:
    - from: "app/Models/Post.php"
      to: "app/Models/Tag.php"
      via: "morphToMany relationship"
      pattern: "morphToMany.*Tag::class.*taggable"
    - from: "app/Models/Comment.php"
      to: "app/Models/Comment.php"
      via: "self-referencing parent/replies"
      pattern: "hasMany.*Comment::class.*parent_id"
---

<objective>
Create Laravel Eloquent models with complete relationships for all content types.

Purpose: Models are the interface between database and application. Without properly defined relationships, seeders and future features won't work.
Output: 6 Eloquent models (User extended, Post, Page, Comment, Category, Tag) with all relationships.
</objective>

<execution_context>
@/Users/shoemoney/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shoemoney/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-migration-models/01-RESEARCH.md
@database/migrations/2026_01_24_000002_create_posts_table.php
@database/migrations/2026_01_24_000008_create_comments_table.php

# Key constraints:
# - User needs author_name (display name/nickname) and wordpress_id
# - Polymorphic many-to-many for tags/categories
# - Self-referencing Comment for threading
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend User Model</name>
  <files>
    app/Models/User.php
  </files>
  <action>
Update the existing User model to include new fields and relationships:

Add to $fillable:
- 'author_name'
- 'wordpress_id'
- 'role'

Add relationships:
```php
public function posts(): HasMany
{
    return $this->hasMany(Post::class);
}

public function pages(): HasMany
{
    return $this->hasMany(Page::class);
}

public function comments(): HasMany
{
    return $this->hasMany(Comment::class);
}
```

Add role constants and helper:
```php
public const ROLE_ADMINISTRATOR = 'administrator';
public const ROLE_EDITOR = 'editor';
public const ROLE_AUTHOR = 'author';

public function isAdministrator(): bool
{
    return $this->role === self::ROLE_ADMINISTRATOR;
}

public function isEditor(): bool
{
    return in_array($this->role, [self::ROLE_ADMINISTRATOR, self::ROLE_EDITOR]);
}
```

Add accessor for display name (prefers author_name, falls back to name):
```php
protected function displayName(): Attribute
{
    return Attribute::make(
        get: fn () => $this->author_name ?: $this->name,
    );
}
```

Import required classes: HasMany, Attribute from Illuminate\Database\Eloquent.
  </action>
  <verify>
Run: `php artisan tinker --execute="App\Models\User::make(['name' => 'Test', 'author_name' => 'TestAuthor'])->display_name;"` returns 'TestAuthor'
  </verify>
  <done>
User model extended with author_name, wordpress_id, role, relationships to posts/pages/comments, and role helpers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Post and Page Models</name>
  <files>
    app/Models/Post.php
    app/Models/Page.php
  </files>
  <action>
**Post.php:**
```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\MorphToMany;

class Post extends Model
{
    use HasFactory;

    protected $fillable = [
        'wordpress_id',
        'user_id',
        'title',
        'slug',
        'content',
        'excerpt',
        'status',
        'published_at',
    ];

    protected function casts(): array
    {
        return [
            'published_at' => 'datetime',
        ];
    }

    // Relationships
    public function author(): BelongsTo
    {
        return $this->belongsTo(User::class, 'user_id');
    }

    public function comments(): HasMany
    {
        return $this->hasMany(Comment::class);
    }

    public function tags(): MorphToMany
    {
        return $this->morphToMany(Tag::class, 'taggable')->withTimestamps();
    }

    public function categories(): MorphToMany
    {
        return $this->morphToMany(Category::class, 'categorizable')->withTimestamps();
    }

    // Scopes
    public function scopePublished($query)
    {
        return $query->where('status', 'published')->whereNotNull('published_at');
    }

    public function scopeDraft($query)
    {
        return $query->where('status', 'draft');
    }

    // URL helper for WordPress-style permalinks
    public function getUrlAttribute(): string
    {
        if (!$this->published_at) {
            return '#';
        }
        return sprintf(
            '/%d/%02d/%02d/%s/',
            $this->published_at->year,
            $this->published_at->month,
            $this->published_at->day,
            $this->slug
        );
    }
}
```

**Page.php:**
```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\MorphToMany;

class Page extends Model
{
    use HasFactory;

    protected $fillable = [
        'wordpress_id',
        'user_id',
        'title',
        'slug',
        'content',
        'menu_order',
    ];

    public function author(): BelongsTo
    {
        return $this->belongsTo(User::class, 'user_id');
    }

    public function tags(): MorphToMany
    {
        return $this->morphToMany(Tag::class, 'taggable')->withTimestamps();
    }

    public function categories(): MorphToMany
    {
        return $this->morphToMany(Category::class, 'categorizable')->withTimestamps();
    }

    public function getUrlAttribute(): string
    {
        return '/' . $this->slug . '/';
    }
}
```
  </action>
  <verify>
Run: `php artisan tinker --execute="App\Models\Post::make(['published_at' => '2024-03-15', 'slug' => 'test-post'])->url;"` returns '/2024/03/15/test-post/'
  </verify>
  <done>
Post and Page models created with author relationship, polymorphic tag/category relationships, scopes, and URL helpers.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Comment, Category, and Tag Models</name>
  <files>
    app/Models/Comment.php
    app/Models/Category.php
    app/Models/Tag.php
  </files>
  <action>
**Comment.php:**
```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Comment extends Model
{
    use HasFactory;

    protected $fillable = [
        'wordpress_id',
        'post_id',
        'user_id',
        'parent_id',
        'author_name',
        'author_email',
        'author_url',
        'author_ip',
        'content',
        'status',
    ];

    // Relationships
    public function post(): BelongsTo
    {
        return $this->belongsTo(Post::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function parent(): BelongsTo
    {
        return $this->belongsTo(Comment::class, 'parent_id');
    }

    public function replies(): HasMany
    {
        return $this->hasMany(Comment::class, 'parent_id');
    }

    // Scopes
    public function scopeApproved($query)
    {
        return $query->where('status', 'approved');
    }

    public function scopePending($query)
    {
        return $query->where('status', 'pending');
    }

    public function scopeRootComments($query)
    {
        return $query->whereNull('parent_id');
    }

    // Gravatar URL helper
    public function getGravatarUrlAttribute(): string
    {
        $hash = md5(strtolower(trim($this->author_email)));
        return "https://www.gravatar.com/avatar/{$hash}?d=mp&s=80";
    }

    // Check if this comment is a reply
    public function isReply(): bool
    {
        return $this->parent_id !== null;
    }
}
```

**Category.php:**
```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphToMany;

class Category extends Model
{
    use HasFactory;

    protected $fillable = [
        'wordpress_id',
        'name',
        'slug',
        'description',
    ];

    public function posts(): MorphToMany
    {
        return $this->morphedByMany(Post::class, 'categorizable')->withTimestamps();
    }

    public function pages(): MorphToMany
    {
        return $this->morphedByMany(Page::class, 'categorizable')->withTimestamps();
    }

    public function getUrlAttribute(): string
    {
        return '/category/' . $this->slug . '/';
    }
}
```

**Tag.php:**
```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphToMany;

class Tag extends Model
{
    use HasFactory;

    protected $fillable = [
        'wordpress_id',
        'name',
        'slug',
    ];

    public function posts(): MorphToMany
    {
        return $this->morphedByMany(Post::class, 'taggable')->withTimestamps();
    }

    public function pages(): MorphToMany
    {
        return $this->morphedByMany(Page::class, 'taggable')->withTimestamps();
    }

    public function getUrlAttribute(): string
    {
        return '/tag/' . $this->slug . '/';
    }
}
```
  </action>
  <verify>
Run: `php artisan tinker --execute="App\Models\Comment::make(['author_email' => 'test@example.com'])->gravatar_url;"` returns Gravatar URL string
  </verify>
  <done>
Comment model with threading (parent/replies), Category and Tag models with inverse polymorphic relationships created.
  </done>
</task>

</tasks>

<verification>
1. All 6 model files exist with proper namespace and class definitions
2. User model has posts(), pages(), comments() relationships
3. Post model has tags(), categories(), author(), comments() relationships
4. Comment model has parent(), replies() self-referencing relationships
5. Polymorphic relationships work: Post->tags(), Tag->posts()
6. URL accessors return correct WordPress-style URLs
</verification>

<success_criteria>
- User model extended with author_name, wordpress_id, role, and relationships
- Post and Page models with polymorphic tag/category relationships
- Comment model with self-referencing parent/replies for threading
- Category and Tag models with inverse polymorphic relationships
- All models have appropriate scopes (published, approved, etc.)
- URL helpers match WordPress permalink structure
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-migration-models/01-03-SUMMARY.md`
</output>
