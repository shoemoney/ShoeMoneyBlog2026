---
phase: 01-data-migration-models
plan: 07
type: execute
wave: 6
depends_on: ["01-06"]
files_modified:
  - app/Console/Commands/VerifyMigration.php
  - app/Console/Commands/AuditShortcodes.php
autonomous: false

must_haves:
  truths:
    - "Migration counts verified against WordPress source"
    - "Shortcodes in content identified and cataloged"
    - "Comment threading depth verified"
    - "Taxonomy relationships verified"
  artifacts:
    - path: "app/Console/Commands/VerifyMigration.php"
      provides: "Migration verification command"
      contains: "signature = 'migration:verify'"
    - path: "app/Console/Commands/AuditShortcodes.php"
      provides: "Shortcode audit command"
      contains: "signature = 'migration:audit-shortcodes'"
  key_links:
    - from: "app/Console/Commands/VerifyMigration.php"
      to: "app/Models/WordPress/*"
      via: "compares counts between databases"
      pattern: "Wp.*::count()"
---

<objective>
Create verification commands to validate migration integrity and audit shortcodes for conversion.

Purpose: Ensures data integrity before proceeding. Identifies shortcodes that need conversion to HTML.
Output: Two artisan commands: migration:verify (validates counts and relationships) and migration:audit-shortcodes (catalogs shortcodes in content).
</objective>

<execution_context>
@/Users/shoemoney/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shoemoney/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-migration-models/01-RESEARCH.md
@app/Models/WordPress/WpPost.php
@app/Models/WordPress/WpComment.php
@app/Models/Post.php
@app/Models/Comment.php

# Phase 1 Success Criteria to verify:
# 1. All WordPress posts, users, comments, categories, tags exist in Laravel
# 2. (SKIP - user handles manually) Password migration
# 3. Post content renders without broken shortcodes
# 4. Comment threading preserved
# 5. User roles mapped correctly

# Expected counts:
# - Posts: 3,870
# - Pages: 159
# - Comments: 160,569
# - Users: 12
# - Categories: 14
# - Tags: 15,448
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Migration Verification Command</name>
  <files>
    app/Console/Commands/VerifyMigration.php
  </files>
  <action>
Create artisan command to verify migration integrity:

```php
<?php

namespace App\Console\Commands;

use App\Models\Category;
use App\Models\Comment;
use App\Models\Page;
use App\Models\Post;
use App\Models\Tag;
use App\Models\User;
use App\Models\WordPress\WpComment;
use App\Models\WordPress\WpPost;
use App\Models\WordPress\WpTermTaxonomy;
use App\Models\WordPress\WpUser;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;

class VerifyMigration extends Command
{
    protected $signature = 'migration:verify {--fix : Attempt to fix discrepancies}';
    protected $description = 'Verify WordPress to Laravel migration integrity';

    private array $issues = [];
    private array $passed = [];

    public function handle(): int
    {
        $this->info('');
        $this->info('Verifying WordPress to Laravel migration...');
        $this->info('');

        $this->verifyUsers();
        $this->verifyCategories();
        $this->verifyTags();
        $this->verifyPosts();
        $this->verifyPages();
        $this->verifyComments();
        $this->verifyCommentThreading();
        $this->verifyTaxonomyRelationships();
        $this->verifyUserRoles();

        $this->printResults();

        return empty($this->issues) ? Command::SUCCESS : Command::FAILURE;
    }

    private function verifyUsers(): void
    {
        $wpCount = WpUser::count();
        $laravelCount = User::whereNotNull('wordpress_id')->count();

        if ($wpCount === $laravelCount) {
            $this->passed[] = "Users: {$laravelCount}/{$wpCount} OK";
        } else {
            $this->issues[] = "Users: Expected {$wpCount}, found {$laravelCount}";
        }
    }

    private function verifyCategories(): void
    {
        $wpCount = WpTermTaxonomy::categories()->count();
        $laravelCount = Category::count();

        if ($wpCount === $laravelCount) {
            $this->passed[] = "Categories: {$laravelCount}/{$wpCount} OK";
        } else {
            $this->issues[] = "Categories: Expected {$wpCount}, found {$laravelCount}";
        }
    }

    private function verifyTags(): void
    {
        $wpCount = WpTermTaxonomy::tags()->count();
        $laravelCount = Tag::count();

        if ($wpCount === $laravelCount) {
            $this->passed[] = "Tags: {$laravelCount}/{$wpCount} OK";
        } else {
            $this->issues[] = "Tags: Expected {$wpCount}, found {$laravelCount}";
        }
    }

    private function verifyPosts(): void
    {
        $wpCount = WpPost::published()->posts()->count();
        $laravelCount = Post::count();

        if ($wpCount === $laravelCount) {
            $this->passed[] = "Posts: {$laravelCount}/{$wpCount} OK";
        } else {
            $this->issues[] = "Posts: Expected {$wpCount}, found {$laravelCount}";
        }
    }

    private function verifyPages(): void
    {
        $wpCount = WpPost::published()->pages()->count();
        $laravelCount = Page::count();

        if ($wpCount === $laravelCount) {
            $this->passed[] = "Pages: {$laravelCount}/{$wpCount} OK";
        } else {
            $this->issues[] = "Pages: Expected {$wpCount}, found {$laravelCount}";
        }
    }

    private function verifyComments(): void
    {
        $wpCount = WpComment::approved()->count();
        $laravelCount = Comment::count();

        // Allow small variance for orphaned comments
        $tolerance = ceil($wpCount * 0.001); // 0.1% tolerance

        if (abs($wpCount - $laravelCount) <= $tolerance) {
            $this->passed[] = "Comments: {$laravelCount}/{$wpCount} OK (within tolerance)";
        } else {
            $this->issues[] = "Comments: Expected ~{$wpCount}, found {$laravelCount}";
        }
    }

    private function verifyCommentThreading(): void
    {
        // Count WordPress threaded comments
        $wpThreaded = WpComment::approved()->where('comment_parent', '>', 0)->count();

        // Count Laravel threaded comments
        $laravelThreaded = Comment::whereNotNull('parent_id')->count();

        $tolerance = ceil($wpThreaded * 0.01); // 1% tolerance

        if (abs($wpThreaded - $laravelThreaded) <= $tolerance) {
            $this->passed[] = "Comment Threading: {$laravelThreaded}/{$wpThreaded} OK";
        } else {
            $this->issues[] = "Comment Threading: Expected ~{$wpThreaded} threaded, found {$laravelThreaded}";
        }

        // Verify no orphaned parent_ids
        $orphanedReplies = Comment::whereNotNull('parent_id')
            ->whereDoesntHave('parent')
            ->count();

        if ($orphanedReplies === 0) {
            $this->passed[] = "Comment Parents: No orphaned replies";
        } else {
            $this->issues[] = "Comment Parents: {$orphanedReplies} orphaned replies (parent missing)";
        }
    }

    private function verifyTaxonomyRelationships(): void
    {
        // Sample check: verify posts have categories/tags
        $postsWithCategories = DB::table('categorizables')
            ->where('categorizable_type', Post::class)
            ->distinct('categorizable_id')
            ->count('categorizable_id');

        $postsWithTags = DB::table('taggables')
            ->where('taggable_type', Post::class)
            ->distinct('taggable_id')
            ->count('taggable_id');

        $totalPosts = Post::count();

        $this->passed[] = "Posts with categories: {$postsWithCategories}/{$totalPosts}";
        $this->passed[] = "Posts with tags: {$postsWithTags}/{$totalPosts}";

        // Verify relationship works both ways
        $samplePost = Post::has('categories')->first();
        if ($samplePost && $samplePost->categories()->count() > 0) {
            $this->passed[] = "Post->categories relationship: Working";
        } else {
            $this->issues[] = "Post->categories relationship: Not working";
        }

        $sampleCategory = Category::has('posts')->first();
        if ($sampleCategory && $sampleCategory->posts()->count() > 0) {
            $this->passed[] = "Category->posts relationship: Working";
        } else {
            $this->issues[] = "Category->posts relationship: Not working";
        }
    }

    private function verifyUserRoles(): void
    {
        $administrators = User::where('role', User::ROLE_ADMINISTRATOR)->count();
        $editors = User::where('role', User::ROLE_EDITOR)->count();
        $authors = User::where('role', User::ROLE_AUTHOR)->count();

        $total = $administrators + $editors + $authors;
        $expected = User::whereNotNull('wordpress_id')->count();

        if ($total === $expected) {
            $this->passed[] = "User Roles: {$administrators} admins, {$editors} editors, {$authors} authors";
        } else {
            $this->issues[] = "User Roles: {$total} assigned, expected {$expected}";
        }
    }

    private function printResults(): void
    {
        $this->newLine();

        if (!empty($this->passed)) {
            $this->info('PASSED:');
            foreach ($this->passed as $pass) {
                $this->line("  [OK] {$pass}");
            }
        }

        if (!empty($this->issues)) {
            $this->newLine();
            $this->error('ISSUES:');
            foreach ($this->issues as $issue) {
                $this->line("  [!!] {$issue}");
            }
        }

        $this->newLine();
        if (empty($this->issues)) {
            $this->info('Migration verification PASSED');
        } else {
            $this->error('Migration verification FAILED - ' . count($this->issues) . ' issue(s)');
        }
    }
}
```
  </action>
  <verify>
Run full pipeline test to verify command validates migration correctly:
`php artisan migrate:fresh && php artisan db:seed && php artisan migration:verify`

Expected:
- migrate:fresh completes successfully
- db:seed completes successfully
- migration:verify returns success (exit code 0)
- Output shows all passed checks for data types
  </verify>
  <done>
VerifyMigration command created, validates all migrated data against WordPress source.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Shortcode Audit Command</name>
  <files>
    app/Console/Commands/AuditShortcodes.php
  </files>
  <action>
Create command to identify shortcodes in content for conversion planning:

```php
<?php

namespace App\Console\Commands;

use App\Models\Post;
use App\Models\Page;
use Illuminate\Console\Command;

class AuditShortcodes extends Command
{
    protected $signature = 'migration:audit-shortcodes {--export : Export results to file}';
    protected $description = 'Audit WordPress shortcodes in migrated content';

    private array $shortcodes = [];

    public function handle(): int
    {
        $this->info('Auditing shortcodes in migrated content...');
        $this->newLine();

        // Regex to match WordPress shortcodes: [shortcode] or [shortcode attr="value"]
        $pattern = '/\[([a-zA-Z_][a-zA-Z0-9_-]*)[^\]]*\]/';

        $this->info('Scanning posts...');
        $bar = $this->output->createProgressBar(Post::count());

        Post::chunk(500, function ($posts) use ($pattern, $bar) {
            foreach ($posts as $post) {
                preg_match_all($pattern, $post->content, $matches);
                foreach ($matches[1] as $shortcode) {
                    $shortcode = strtolower($shortcode);
                    if (!isset($this->shortcodes[$shortcode])) {
                        $this->shortcodes[$shortcode] = [
                            'count' => 0,
                            'posts' => [],
                            'example' => null,
                        ];
                    }
                    $this->shortcodes[$shortcode]['count']++;
                    if (count($this->shortcodes[$shortcode]['posts']) < 5) {
                        $this->shortcodes[$shortcode]['posts'][] = $post->id;
                    }
                    if (!$this->shortcodes[$shortcode]['example']) {
                        // Find full shortcode for example
                        preg_match('/\[' . preg_quote($shortcode, '/') . '[^\]]*\]/', $post->content, $full);
                        $this->shortcodes[$shortcode]['example'] = $full[0] ?? "[{$shortcode}]";
                    }
                }
                $bar->advance();
            }
        });

        $bar->finish();
        $this->newLine();

        $this->info('Scanning pages...');
        Page::chunk(100, function ($pages) use ($pattern) {
            foreach ($pages as $page) {
                preg_match_all($pattern, $page->content, $matches);
                foreach ($matches[1] as $shortcode) {
                    $shortcode = strtolower($shortcode);
                    if (!isset($this->shortcodes[$shortcode])) {
                        $this->shortcodes[$shortcode] = [
                            'count' => 0,
                            'posts' => [],
                            'example' => null,
                        ];
                    }
                    $this->shortcodes[$shortcode]['count']++;
                }
            }
        });

        $this->printResults();

        if ($this->option('export')) {
            $this->exportResults();
        }

        return Command::SUCCESS;
    }

    private function printResults(): void
    {
        $this->newLine();

        if (empty($this->shortcodes)) {
            $this->info('No shortcodes found in content!');
            return;
        }

        // Sort by count descending
        uasort($this->shortcodes, fn($a, $b) => $b['count'] <=> $a['count']);

        $this->info('Shortcodes found:');
        $this->newLine();

        $tableData = [];
        foreach ($this->shortcodes as $shortcode => $data) {
            $tableData[] = [
                $shortcode,
                $data['count'],
                substr($data['example'], 0, 60) . (strlen($data['example']) > 60 ? '...' : ''),
            ];
        }

        $this->table(['Shortcode', 'Count', 'Example'], $tableData);

        $this->newLine();
        $totalUsages = array_sum(array_column($this->shortcodes, 'count'));
        $this->info("Total: " . count($this->shortcodes) . " unique shortcodes, {$totalUsages} usages");

        $this->newLine();
        $this->warn('Recommendation:');
        $this->line('  - Shortcodes with < 10 usages: Convert manually during migration');
        $this->line('  - Shortcodes with > 10 usages: Consider creating Blade components or conversion script');
    }

    private function exportResults(): void
    {
        $filename = storage_path('app/shortcode-audit-' . date('Y-m-d-His') . '.json');

        $export = [
            'generated_at' => now()->toIso8601String(),
            'total_unique' => count($this->shortcodes),
            'total_usages' => array_sum(array_column($this->shortcodes, 'count')),
            'shortcodes' => $this->shortcodes,
        ];

        file_put_contents($filename, json_encode($export, JSON_PRETTY_PRINT));

        $this->info("Results exported to: {$filename}");
    }
}
```

This command:
- Scans all posts and pages for WordPress shortcodes
- Counts occurrences of each shortcode type
- Shows example usage for conversion planning
- Can export to JSON for detailed analysis
  </action>
  <verify>
Run: `php artisan migration:audit-shortcodes`
Expected: Table showing shortcodes found (may be empty if no shortcodes used)
  </verify>
  <done>
AuditShortcodes command created, catalogs all shortcodes for conversion planning.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 1 migration with verification:
- WordPress database connection and models
- Laravel schema migrations
- Laravel Eloquent models with relationships
- All seeders (users, categories, tags, posts, pages, taxonomy relationships, comments)
- Migration verification command
- Shortcode audit command
  </what-built>
  <how-to-verify>
1. Run full migration: `php artisan migrate:fresh && php artisan db:seed`
2. Run verification: `php artisan migration:verify`
3. Check shortcodes: `php artisan migration:audit-shortcodes`
4. Verify counts in verification output match expectations:
   - Posts: ~3,870
   - Pages: ~159
   - Comments: ~160,569
   - Users: 12
   - Categories: 14
   - Tags: ~15,448
5. Verify comment threading shows threaded replies exist
6. Verify taxonomy relationships show posts linked to categories/tags
7. If shortcodes found, review the list for conversion needs
  </how-to-verify>
  <resume-signal>Type "approved" if verification passes, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. `php artisan migration:verify` returns success (exit code 0)
2. All entity counts within tolerance of WordPress source
3. Comment threading verified (parent-child relationships work)
4. Taxonomy relationships verified (posts have categories/tags)
5. User roles mapped correctly
6. `php artisan migration:audit-shortcodes` completes and shows shortcode inventory
</verification>

<success_criteria>
- Migration verification passes all checks
- Shortcode audit identifies any shortcodes needing conversion
- Phase 1 success criteria met:
  - All WordPress posts/users/comments/categories/tags exist in Laravel
  - Comment threading preserved
  - User roles mapped (Administrator, Editor, Author)
  - (Password migration skipped - user handles manually)
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-migration-models/01-07-SUMMARY.md`
</output>
