---
phase: 01-data-migration-models
plan: 05
type: execute
wave: 4
depends_on: ["01-04"]
files_modified:
  - database/seeders/PostSeeder.php
  - database/seeders/PageSeeder.php
  - database/seeders/TaxonomyRelationshipSeeder.php
  - database/seeders/DatabaseSeeder.php
autonomous: true

must_haves:
  truths:
    - "All 3,870 published posts exist in Laravel posts table"
    - "All 159 pages exist in Laravel pages table"
    - "Posts are linked to their categories via categorizables pivot"
    - "Posts are linked to their tags via taggables pivot"
  artifacts:
    - path: "database/seeders/PostSeeder.php"
      provides: "Post migration seeder"
      contains: "chunk"
    - path: "database/seeders/PageSeeder.php"
      provides: "Page migration seeder"
      contains: "WpPost"
    - path: "database/seeders/TaxonomyRelationshipSeeder.php"
      provides: "Taxonomy pivot seeder"
      contains: "taggables"
  key_links:
    - from: "database/seeders/PostSeeder.php"
      to: "app/Models/Post.php"
      via: "creates posts with user_id FK"
      pattern: "Post::upsert"
    - from: "database/seeders/TaxonomyRelationshipSeeder.php"
      to: "app/Models/Tag.php"
      via: "creates taggables pivot records"
      pattern: "taggables.*insert"
---

<objective>
Create seeders for posts, pages, and their taxonomy relationships.

Purpose: Content is the core data. Posts and pages must be migrated before comments can be associated.
Output: 3 seeders (PostSeeder, PageSeeder, TaxonomyRelationshipSeeder) migrating all content and taxonomy links.
</objective>

<execution_context>
@/Users/shoemoney/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shoemoney/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-migration-models/01-RESEARCH.md
@app/Models/WordPress/WpPost.php
@app/Models/WordPress/WpTermTaxonomy.php
@app/Models/Post.php
@app/Models/Page.php
@app/Models/Tag.php
@app/Models/Category.php

# Data volumes:
# - Posts: 3,870 (chunk for safety)
# - Pages: 159 (small, no chunking needed)
# - Taxonomy relationships: varies per post (some have many tags)

# WordPress facts:
# - Prefix: wp2_
# - term_relationships uses object_id (post ID) and term_taxonomy_id
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Post Seeder</name>
  <files>
    database/seeders/PostSeeder.php
  </files>
  <action>
Create PostSeeder that migrates all published posts with chunking:

```php
<?php

namespace Database\Seeders;

use App\Models\Post;
use App\Models\User;
use App\Models\WordPress\WpPost;
use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\DB;

class PostSeeder extends Seeder
{
    public function run(): void
    {
        $this->command->info('Migrating WordPress posts...');

        // Build user ID mapping (WordPress ID -> Laravel ID)
        $userMap = User::whereNotNull('wordpress_id')
            ->pluck('id', 'wordpress_id')
            ->toArray();

        $total = WpPost::published()->posts()->count();
        $bar = $this->command->getOutput()->createProgressBar($total);
        $bar->start();

        WpPost::published()
            ->posts()
            ->orderBy('post_date', 'asc')
            ->chunk(100, function ($wpPosts) use ($userMap, $bar) {
                $postsData = [];

                foreach ($wpPosts as $wpPost) {
                    // Map WordPress author to Laravel user
                    $userId = $userMap[$wpPost->post_author] ?? null;

                    if (!$userId) {
                        $this->command->warn("  Skipping post {$wpPost->ID}: author {$wpPost->post_author} not found");
                        continue;
                    }

                    $postsData[] = [
                        'wordpress_id' => $wpPost->ID,
                        'user_id' => $userId,
                        'title' => $wpPost->post_title,
                        'slug' => $wpPost->post_name,
                        'content' => $wpPost->post_content,
                        'excerpt' => $wpPost->post_excerpt ?: null,
                        'status' => 'published',
                        'published_at' => $wpPost->post_date,
                        'created_at' => $wpPost->post_date,
                        'updated_at' => $wpPost->post_modified,
                    ];
                }

                if (!empty($postsData)) {
                    Post::upsert(
                        $postsData,
                        ['wordpress_id'],
                        ['user_id', 'title', 'slug', 'content', 'excerpt', 'status', 'published_at', 'updated_at']
                    );
                }

                $bar->advance(count($postsData));
            });

        $bar->finish();
        $this->command->newLine();
        $this->command->info("Migrated posts. Laravel count: " . Post::count());
    }
}
```

Key points:
- Maps WordPress post_author to Laravel user_id using wordpress_id
- Uses upsert for idempotency
- Chunks 100 posts at a time (3,870 total)
- Preserves original timestamps (post_date, post_modified)
  </action>
  <verify>
Run: `php artisan db:seed --class=PostSeeder` shows progress bar and final count of ~3,870 posts
  </verify>
  <done>
PostSeeder migrates all published WordPress posts with author mapping and chunked processing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Page Seeder</name>
  <files>
    database/seeders/PageSeeder.php
  </files>
  <action>
Create PageSeeder for WordPress pages:

```php
<?php

namespace Database\Seeders;

use App\Models\Page;
use App\Models\User;
use App\Models\WordPress\WpPost;
use Illuminate\Database\Seeder;

class PageSeeder extends Seeder
{
    public function run(): void
    {
        $this->command->info('Migrating WordPress pages...');

        // Build user ID mapping
        $userMap = User::whereNotNull('wordpress_id')
            ->pluck('id', 'wordpress_id')
            ->toArray();

        $wpPages = WpPost::published()->pages()->get();

        foreach ($wpPages as $wpPage) {
            $userId = $userMap[$wpPage->post_author] ?? null;

            if (!$userId) {
                $this->command->warn("  Skipping page {$wpPage->ID}: author {$wpPage->post_author} not found");
                continue;
            }

            Page::updateOrCreate(
                ['wordpress_id' => $wpPage->ID],
                [
                    'user_id' => $userId,
                    'title' => $wpPage->post_title,
                    'slug' => $wpPage->post_name,
                    'content' => $wpPage->post_content,
                    'menu_order' => $wpPage->menu_order ?? 0,
                    'created_at' => $wpPage->post_date,
                    'updated_at' => $wpPage->post_modified,
                ]
            );
        }

        $this->command->info("Migrated {$wpPages->count()} pages.");
    }
}
```

Pages are simpler than posts - no chunking needed for 159 records.
  </action>
  <verify>
Run: `php artisan db:seed --class=PageSeeder` shows "Migrated 159 pages" (approximately)
  </verify>
  <done>
PageSeeder migrates all published WordPress pages with author mapping.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Taxonomy Relationship Seeder</name>
  <files>
    database/seeders/TaxonomyRelationshipSeeder.php
    database/seeders/DatabaseSeeder.php
  </files>
  <action>
**TaxonomyRelationshipSeeder.php:**
Create seeder that links posts to their categories and tags:

```php
<?php

namespace Database\Seeders;

use App\Models\Category;
use App\Models\Post;
use App\Models\Tag;
use App\Models\WordPress\WpPost;
use App\Models\WordPress\WpTermTaxonomy;
use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\DB;

class TaxonomyRelationshipSeeder extends Seeder
{
    public function run(): void
    {
        $this->command->info('Migrating taxonomy relationships...');

        // Build lookup maps
        $postMap = Post::pluck('id', 'wordpress_id')->toArray();
        $categoryMap = Category::pluck('id', 'wordpress_id')->toArray();
        $tagMap = Tag::pluck('id', 'wordpress_id')->toArray();

        // Clear existing relationships (for idempotency)
        DB::table('categorizables')->where('categorizable_type', Post::class)->delete();
        DB::table('taggables')->where('taggable_type', Post::class)->delete();

        $total = WpPost::published()->posts()->count();
        $bar = $this->command->getOutput()->createProgressBar($total);
        $bar->start();

        $categorizablesData = [];
        $taggablesData = [];

        WpPost::published()
            ->posts()
            ->with(['termTaxonomies.term'])
            ->chunk(100, function ($wpPosts) use ($postMap, $categoryMap, $tagMap, &$categorizablesData, &$taggablesData, $bar) {
                foreach ($wpPosts as $wpPost) {
                    $laravelPostId = $postMap[$wpPost->ID] ?? null;
                    if (!$laravelPostId) continue;

                    foreach ($wpPost->termTaxonomies as $termTax) {
                        if ($termTax->taxonomy === 'category') {
                            $categoryId = $categoryMap[$termTax->term_taxonomy_id] ?? null;
                            if ($categoryId) {
                                $categorizablesData[] = [
                                    'category_id' => $categoryId,
                                    'categorizable_id' => $laravelPostId,
                                    'categorizable_type' => Post::class,
                                    'created_at' => now(),
                                    'updated_at' => now(),
                                ];
                            }
                        } elseif ($termTax->taxonomy === 'post_tag') {
                            $tagId = $tagMap[$termTax->term_taxonomy_id] ?? null;
                            if ($tagId) {
                                $taggablesData[] = [
                                    'tag_id' => $tagId,
                                    'taggable_id' => $laravelPostId,
                                    'taggable_type' => Post::class,
                                    'created_at' => now(),
                                    'updated_at' => now(),
                                ];
                            }
                        }
                    }

                    // Batch insert every 1000 relationships
                    if (count($categorizablesData) >= 1000) {
                        DB::table('categorizables')->insert($categorizablesData);
                        $categorizablesData = [];
                    }
                    if (count($taggablesData) >= 1000) {
                        DB::table('taggables')->insert($taggablesData);
                        $taggablesData = [];
                    }

                    $bar->advance();
                }
            });

        // Insert remaining records
        if (!empty($categorizablesData)) {
            DB::table('categorizables')->insert($categorizablesData);
        }
        if (!empty($taggablesData)) {
            DB::table('taggables')->insert($taggablesData);
        }

        $bar->finish();
        $this->command->newLine();

        $catCount = DB::table('categorizables')->where('categorizable_type', Post::class)->count();
        $tagCount = DB::table('taggables')->where('taggable_type', Post::class)->count();
        $this->command->info("Created {$catCount} category relationships, {$tagCount} tag relationships.");
    }
}
```

**Update DatabaseSeeder.php** to add the new seeders:

```php
<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    public function run(): void
    {
        $this->command->info('=== WordPress Migration Seeders ===');
        $this->command->newLine();

        // Phase 1: Foundation (no dependencies)
        $this->call([
            UserSeeder::class,
            CategorySeeder::class,
            TagSeeder::class,
        ]);

        // Phase 2: Content (depends on users and taxonomies)
        $this->call([
            PostSeeder::class,
            PageSeeder::class,
            TaxonomyRelationshipSeeder::class,
        ]);

        // Phase 3: Engagement (depends on posts)
        // CommentSeeder - Added in Plan 06

        $this->command->newLine();
        $this->command->info('=== Migration Complete ===');
    }
}
```

Key points:
- Uses term_taxonomy_id for mapping (not term_id) - critical WordPress detail
- Batch inserts relationships for performance
- Clears existing relationships first for idempotency
- Handles both categories and tags in single pass
  </action>
  <verify>
Run: `php artisan db:seed --class=TaxonomyRelationshipSeeder` shows relationship counts
Verify: `php artisan tinker --execute="App\Models\Post::first()->tags()->count();"` returns > 0
  </verify>
  <done>
TaxonomyRelationshipSeeder links posts to their categories and tags via polymorphic pivot tables.
  </done>
</task>

</tasks>

<verification>
1. `php artisan db:seed --class=PostSeeder` creates ~3,870 posts
2. `php artisan db:seed --class=PageSeeder` creates ~159 pages
3. `php artisan db:seed --class=TaxonomyRelationshipSeeder` creates pivot records
4. `Post::first()->tags()->count()` returns > 0
5. `Post::first()->categories()->count()` returns >= 0 (not all posts have categories)
6. `Category::first()->posts()->count()` returns > 0
7. `Tag::first()->posts()->count()` returns > 0
8. `php artisan db:seed` runs all seeders in correct order
</verification>

<success_criteria>
- ~3,870 posts migrated with correct author associations
- ~159 pages migrated with correct author associations
- All category relationships preserved in categorizables pivot
- All tag relationships preserved in taggables pivot
- Polymorphic relationships work bidirectionally (Post->tags, Tag->posts)
- All seeders are idempotent
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-migration-models/01-05-SUMMARY.md`
</output>
