---
phase: 02-url-preservation-routing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - routes/web.php
autonomous: true

must_haves:
  truths:
    - "Date-based post URLs like /2015/08/15/slug/ are routable"
    - "Category URLs like /category/marketing/ are routable"
    - "Tag URLs like /tag/seo/ are routable"
    - "Page URLs like /about/ are routable"
  artifacts:
    - path: "routes/web.php"
      provides: "WordPress-compatible route definitions"
      contains: "Route::get('/{year}/{month}/{day}/{slug}'"
  key_links:
    - from: "routes/web.php"
      to: "PostController"
      via: "Route action"
      pattern: "PostController::class"
---

<objective>
Define Laravel routes that exactly match WordPress permalink structures for posts, pages, categories, and tags.

Purpose: Routes are the foundation for URL preservation. Without correct route definitions, no URL will resolve.
Output: routes/web.php with WordPress-compatible route patterns
</objective>

<execution_context>
@/Users/shoemoney/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shoemoney/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-url-preservation-routing/02-RESEARCH.md
@app/Models/Post.php
@app/Models/Page.php
@app/Models/Category.php
@app/Models/Tag.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define WordPress-compatible routes</name>
  <files>routes/web.php</files>
  <action>
Replace the default welcome route with WordPress-compatible routes:

1. **Date-based post route** (must come FIRST - most specific):
```php
Route::get('/{year}/{month}/{day}/{slug}', [PostController::class, 'show'])
    ->where([
        'year' => '[0-9]{4}',
        'month' => '[0-9]{2}',
        'day' => '[0-9]{2}',
        'slug' => '[a-z0-9\-]+',
    ])
    ->name('post.show');
```

2. **Category archive route**:
```php
Route::get('/category/{slug}', [CategoryController::class, 'show'])
    ->where('slug', '[a-z0-9\-]+')
    ->name('category.show');
```

3. **Tag archive route**:
```php
Route::get('/tag/{slug}', [TagController::class, 'show'])
    ->where('slug', '[a-z0-9\-]+')
    ->name('tag.show');
```

4. **Homepage route** (for future blog listing):
```php
Route::get('/', [PostController::class, 'index'])->name('home');
```

5. **Page route** (MUST be LAST - catch-all for slugs):
```php
Route::get('/{slug}', [PageController::class, 'show'])
    ->where('slug', '[a-z0-9\-]+')
    ->name('page.show');
```

Add the controller use statements at the top:
```php
use App\Http\Controllers\PostController;
use App\Http\Controllers\PageController;
use App\Http\Controllers\CategoryController;
use App\Http\Controllers\TagController;
```

**CRITICAL ORDER**: Post route BEFORE page route. Date pattern is more specific than single slug.
  </action>
  <verify>Run `php artisan route:list` and verify all 5 routes are registered with correct patterns</verify>
  <done>Route list shows: post.show with {year}/{month}/{day}/{slug}, category.show, tag.show, home, page.show as last catch-all</done>
</task>

<task type="auto">
  <name>Task 2: Create placeholder controllers</name>
  <files>
    app/Http/Controllers/PostController.php
    app/Http/Controllers/PageController.php
    app/Http/Controllers/CategoryController.php
    app/Http/Controllers/TagController.php
  </files>
  <action>
Create minimal controller stubs so routes can be resolved. These will be fully implemented in Plan 02.

For each controller, create a stub with placeholder methods:

**PostController.php**:
```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class PostController extends Controller
{
    public function index()
    {
        return response('Homepage - to be implemented', 200);
    }

    public function show(string $year, string $month, string $day, string $slug)
    {
        return response("Post: $year/$month/$day/$slug - to be implemented", 200);
    }
}
```

**PageController.php**:
```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class PageController extends Controller
{
    public function show(string $slug)
    {
        return response("Page: $slug - to be implemented", 200);
    }
}
```

**CategoryController.php**:
```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class CategoryController extends Controller
{
    public function show(string $slug)
    {
        return response("Category: $slug - to be implemented", 200);
    }
}
```

**TagController.php**:
```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class TagController extends Controller
{
    public function show(string $slug)
    {
        return response("Tag: $slug - to be implemented", 200);
    }
}
```
  </action>
  <verify>
Run each test to verify routes resolve:
```bash
php artisan serve &
curl -s http://localhost:8000/2015/08/15/test-post/
curl -s http://localhost:8000/category/marketing/
curl -s http://localhost:8000/tag/seo/
curl -s http://localhost:8000/about/
curl -s http://localhost:8000/
```
All should return 200 with placeholder text.
  </verify>
  <done>All 5 route patterns return 200 responses with placeholder content</done>
</task>

</tasks>

<verification>
1. `php artisan route:list` shows all routes with correct patterns
2. No syntax errors: `php artisan route:clear && php artisan route:cache`
3. Manual curl tests confirm routes resolve (placeholder responses acceptable)
</verification>

<success_criteria>
- Routes defined in correct order (specific before general)
- Date-based post route uses regex constraints for year/month/day
- Page route is last to avoid catching other patterns
- All 4 controllers exist and have stub methods
- `php artisan route:list` shows 5 routes
</success_criteria>

<output>
After completion, create `.planning/phases/02-url-preservation-routing/02-01-SUMMARY.md`
</output>
